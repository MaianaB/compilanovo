/*
 * generated by Xtext 2.14.0
 */
package com.ufcg.compiler.serializer;

import com.google.inject.Inject;
import com.ufcg.compiler.go.ArrayType;
import com.ufcg.compiler.go.ArrayValue;
import com.ufcg.compiler.go.Assignment;
import com.ufcg.compiler.go.BINARY_EXP;
import com.ufcg.compiler.go.BLOCK;
import com.ufcg.compiler.go.BOOLEAN_VALUE;
import com.ufcg.compiler.go.BOOL_OP;
import com.ufcg.compiler.go.BasicType;
import com.ufcg.compiler.go.COMPARISON;
import com.ufcg.compiler.go.Condition;
import com.ufcg.compiler.go.Const;
import com.ufcg.compiler.go.EXPRESSAO;
import com.ufcg.compiler.go.EXPRESSAOLINHA;
import com.ufcg.compiler.go.ForClause;
import com.ufcg.compiler.go.ForDecl;
import com.ufcg.compiler.go.FunctionType;
import com.ufcg.compiler.go.GoDecl;
import com.ufcg.compiler.go.GoPackage;
import com.ufcg.compiler.go.IDList;
import com.ufcg.compiler.go.IGUAL;
import com.ufcg.compiler.go.Init;
import com.ufcg.compiler.go.InitStmt;
import com.ufcg.compiler.go.LITERAIS_BASICOS;
import com.ufcg.compiler.go.LiteraisList;
import com.ufcg.compiler.go.PARAMETER;
import com.ufcg.compiler.go.PONTOSIGUAL;
import com.ufcg.compiler.go.Parameters;
import com.ufcg.compiler.go.PostStmt;
import com.ufcg.compiler.go.Result;
import com.ufcg.compiler.go.SignatureDel;
import com.ufcg.compiler.go.TIPO;
import com.ufcg.compiler.go.Types;
import com.ufcg.compiler.go.Var;
import com.ufcg.compiler.go.VarDecl;
import com.ufcg.compiler.services.GoGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class GoSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GoGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GoPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GoPackage.ARRAY_TYPE:
				sequence_ArrayType(context, (ArrayType) semanticObject); 
				return; 
			case GoPackage.ARRAY_VALUE:
				sequence_ArrayValue(context, (ArrayValue) semanticObject); 
				return; 
			case GoPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case GoPackage.BINARY_EXP:
				sequence_BINARY_EXP(context, (BINARY_EXP) semanticObject); 
				return; 
			case GoPackage.BLOCK:
				sequence_BLOCK(context, (BLOCK) semanticObject); 
				return; 
			case GoPackage.BOOLEAN_VALUE:
				sequence_BOOLEAN_VALUE(context, (BOOLEAN_VALUE) semanticObject); 
				return; 
			case GoPackage.BOOL_OP:
				sequence_BOOL_OP(context, (BOOL_OP) semanticObject); 
				return; 
			case GoPackage.BASIC_TYPE:
				sequence_BasicType(context, (BasicType) semanticObject); 
				return; 
			case GoPackage.COMPARISON:
				sequence_COMPARISON(context, (COMPARISON) semanticObject); 
				return; 
			case GoPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case GoPackage.CONST:
				sequence_Const(context, (Const) semanticObject); 
				return; 
			case GoPackage.EXPRESSAO:
				sequence_EXPRESSAO(context, (EXPRESSAO) semanticObject); 
				return; 
			case GoPackage.EXPRESSAOLINHA:
				sequence_EXPRESSAOLINHA(context, (EXPRESSAOLINHA) semanticObject); 
				return; 
			case GoPackage.FOR_CLAUSE:
				sequence_ForClause(context, (ForClause) semanticObject); 
				return; 
			case GoPackage.FOR_DECL:
				sequence_ForDecl(context, (ForDecl) semanticObject); 
				return; 
			case GoPackage.FUNCTION_TYPE:
				sequence_FunctionType(context, (FunctionType) semanticObject); 
				return; 
			case GoPackage.GO_DECL:
				sequence_GoDecl(context, (GoDecl) semanticObject); 
				return; 
			case GoPackage.ID_LIST:
				sequence_IDList(context, (IDList) semanticObject); 
				return; 
			case GoPackage.IGUAL:
				sequence_IGUAL(context, (IGUAL) semanticObject); 
				return; 
			case GoPackage.INIT:
				sequence_Init(context, (Init) semanticObject); 
				return; 
			case GoPackage.INIT_STMT:
				sequence_InitStmt(context, (InitStmt) semanticObject); 
				return; 
			case GoPackage.LITERAIS_BASICOS:
				sequence_LITERAIS_BASICOS(context, (LITERAIS_BASICOS) semanticObject); 
				return; 
			case GoPackage.LITERAIS_LIST:
				sequence_LiteraisList(context, (LiteraisList) semanticObject); 
				return; 
			case GoPackage.PARAMETER:
				if (rule == grammarAccess.getPARAMETERRule()) {
					sequence_PARAMETER(context, (PARAMETER) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPARAMETERS_LISTRule()) {
					sequence_PARAMETER_PARAMETERS_LIST(context, (PARAMETER) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.PONTOSIGUAL:
				sequence_PONTOSIGUAL(context, (PONTOSIGUAL) semanticObject); 
				return; 
			case GoPackage.PARAMETERS:
				if (rule == grammarAccess.getParametersRule()) {
					sequence_PARAMETER_PARAMETERS_LIST_Parameters(context, (Parameters) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSignatureRule()) {
					sequence_PARAMETER_PARAMETERS_LIST_Parameters_Signature(context, (Parameters) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.POST_STMT:
				sequence_PostStmt(context, (PostStmt) semanticObject); 
				return; 
			case GoPackage.RESULT:
				sequence_Result(context, (Result) semanticObject); 
				return; 
			case GoPackage.SIGNATURE_DEL:
				sequence_SignatureDel(context, (SignatureDel) semanticObject); 
				return; 
			case GoPackage.TIPO:
				sequence_TIPO(context, (TIPO) semanticObject); 
				return; 
			case GoPackage.TYPES:
				sequence_Types(context, (Types) semanticObject); 
				return; 
			case GoPackage.VAR:
				sequence_Var(context, (Var) semanticObject); 
				return; 
			case GoPackage.VAR_DECL:
				sequence_VarDecl(context, (VarDecl) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ArrayType returns ArrayType
	 *
	 * Constraint:
	 *     (qtd=NUMERO? basic=BasicType)
	 */
	protected void sequence_ArrayType(ISerializationContext context, ArrayType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArrayValue returns ArrayValue
	 *
	 * Constraint:
	 *     lit=LiteraisList
	 */
	protected void sequence_ArrayValue(ISerializationContext context, ArrayValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.ARRAY_VALUE__LIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.ARRAY_VALUE__LIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayValueAccess().getLitLiteraisListParserRuleCall_1_0(), semanticObject.getLit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (id=ID qtd=NUMERO? (igual=IGUAL | dois=PONTOSIGUAL) expressao=EXPRESSAOLINHA)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BINARY_EXP returns BINARY_EXP
	 *
	 * Constraint:
	 *     ((basic=LITERAIS_BASICOS (bool=BOOL_OP | arit=ARIT_OP) binabasic=BINARY_EXP) | unique_basic=LITERAIS_BASICOS)
	 */
	protected void sequence_BINARY_EXP(ISerializationContext context, BINARY_EXP semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BLOCK returns BLOCK
	 *
	 * Constraint:
	 *     listaDeComandos+=EXPRESSAO*
	 */
	protected void sequence_BLOCK(ISerializationContext context, BLOCK semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BOOLEAN_VALUE returns BOOLEAN_VALUE
	 *
	 * Constraint:
	 *     (verdadeiro='true' | falso='false')
	 */
	protected void sequence_BOOLEAN_VALUE(ISerializationContext context, BOOLEAN_VALUE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BOOL_OP returns BOOL_OP
	 *
	 * Constraint:
	 *     (and='&' | or='||')
	 */
	protected void sequence_BOOL_OP(ISerializationContext context, BOOL_OP semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicType returns BasicType
	 *
	 * Constraint:
	 *     (string='string' | int='int' | float='float' | boolean='bool')
	 */
	protected void sequence_BasicType(ISerializationContext context, BasicType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     COMPARISON returns COMPARISON
	 *
	 * Constraint:
	 *     (igual='==' | maiorigualque='>=' | menorigualque='<=' | maiorque='>' | menorque='<')
	 */
	protected void sequence_COMPARISON(ISerializationContext context, COMPARISON semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (expr1=EXPRESSAO comparador=COMPARISON expr2=EXPRESSAO)
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONDITION__EXPR1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONDITION__EXPR1));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONDITION__COMPARADOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONDITION__COMPARADOR));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONDITION__EXPR2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONDITION__EXPR2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAccess().getExpr1EXPRESSAOParserRuleCall_0_0(), semanticObject.getExpr1());
		feeder.accept(grammarAccess.getConditionAccess().getComparadorCOMPARISONParserRuleCall_1_0(), semanticObject.getComparador());
		feeder.accept(grammarAccess.getConditionAccess().getExpr2EXPRESSAOParserRuleCall_2_0(), semanticObject.getExpr2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Const returns Const
	 *
	 * Constraint:
	 *     const='const'
	 */
	protected void sequence_Const(ISerializationContext context, Const semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONST__CONST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONST__CONST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstAccess().getConstConstKeyword_0(), semanticObject.getConst());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EXPRESSAOLINHA returns EXPRESSAOLINHA
	 *
	 * Constraint:
	 *     ((exp=EXPRESSAO explinha=EXPRESSAOLINHA) | exp=EXPRESSAO)
	 */
	protected void sequence_EXPRESSAOLINHA(ISerializationContext context, EXPRESSAOLINHA semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EXPRESSAO returns EXPRESSAO
	 *
	 * Constraint:
	 *     (
	 *         declFunction=FunctionType | 
	 *         variaveis=VarDecl | 
	 *         basic=LITERAIS_BASICOS | 
	 *         binary_exp=BINARY_EXP | 
	 *         declFunction=FunctionType | 
	 *         assignment=Assignment | 
	 *         variaveis=VarDecl | 
	 *         for=ForDecl | 
	 *         basic=LITERAIS_BASICOS | 
	 *         arrayValue=ArrayValue
	 *     )
	 */
	protected void sequence_EXPRESSAO(ISerializationContext context, EXPRESSAO semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForClause returns ForClause
	 *
	 * Constraint:
	 *     (init=InitStmt? condition=Condition? post=PostStmt?)
	 */
	protected void sequence_ForClause(ISerializationContext context, ForClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForDecl returns ForDecl
	 *
	 * Constraint:
	 *     (clause=ForClause exp=EXPRESSAOLINHA)
	 */
	protected void sequence_ForDecl(ISerializationContext context, ForDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.FOR_DECL__CLAUSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.FOR_DECL__CLAUSE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.FOR_DECL__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.FOR_DECL__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForDeclAccess().getClauseForClauseParserRuleCall_1_0(), semanticObject.getClause());
		feeder.accept(grammarAccess.getForDeclAccess().getExpEXPRESSAOLINHAParserRuleCall_3_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionType returns FunctionType
	 *
	 * Constraint:
	 *     (nome=ID assinatura=Signature bloco=BLOCK?)
	 */
	protected void sequence_FunctionType(ISerializationContext context, FunctionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GoDecl returns GoDecl
	 *
	 * Constraint:
	 *     (var=VarDecl | func=FunctionType | expressao=EXPRESSAOLINHA)
	 */
	protected void sequence_GoDecl(ISerializationContext context, GoDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IDList returns IDList
	 *
	 * Constraint:
	 *     (idList+=ID | (idList+=ID list+=IDList))
	 */
	protected void sequence_IDList(ISerializationContext context, IDList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IGUAL returns IGUAL
	 *
	 * Constraint:
	 *     igual='='
	 */
	protected void sequence_IGUAL(ISerializationContext context, IGUAL semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.IGUAL__IGUAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.IGUAL__IGUAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIGUALAccess().getIgualEqualsSignKeyword_0(), semanticObject.getIgual());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InitStmt returns InitStmt
	 *
	 * Constraint:
	 *     decl=GoDecl
	 */
	protected void sequence_InitStmt(ISerializationContext context, InitStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.INIT_STMT__DECL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.INIT_STMT__DECL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitStmtAccess().getDeclGoDeclParserRuleCall_0(), semanticObject.getDecl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Init returns Init
	 *
	 * Constraint:
	 *     elements+=GoDecl+
	 */
	protected void sequence_Init(ISerializationContext context, Init semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LITERAIS_BASICOS returns LITERAIS_BASICOS
	 *
	 * Constraint:
	 *     (numero=NUMERO | string=STRING_DECL | booleano=BOOLEAN_VALUE)
	 */
	protected void sequence_LITERAIS_BASICOS(ISerializationContext context, LITERAIS_BASICOS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LiteraisList returns LiteraisList
	 *
	 * Constraint:
	 *     (lit+=LITERAIS_BASICOS | (lit+=LITERAIS_BASICOS lit+=LiteraisList))
	 */
	protected void sequence_LiteraisList(ISerializationContext context, LiteraisList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PARAMETER returns PARAMETER
	 *
	 * Constraint:
	 *     (id=ID tipo=Types)
	 */
	protected void sequence_PARAMETER(ISerializationContext context, PARAMETER semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PARAMETER__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PARAMETER__ID));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PARAMETER__TIPO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PARAMETER__TIPO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPARAMETERAccess().getIdIDTerminalRuleCall_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getPARAMETERAccess().getTipoTypesParserRuleCall_1_0(), semanticObject.getTipo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PARAMETERS_LIST returns PARAMETER
	 *
	 * Constraint:
	 *     (id=ID tipo=Types PARAMETER+=PARAMETER*)
	 */
	protected void sequence_PARAMETER_PARAMETERS_LIST(ISerializationContext context, PARAMETER semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameters returns Parameters
	 *
	 * Constraint:
	 *     (id=ID tipo=Types PARAMETER+=PARAMETER*)?
	 */
	protected void sequence_PARAMETER_PARAMETERS_LIST_Parameters(ISerializationContext context, Parameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Signature returns Parameters
	 *
	 * Constraint:
	 *     ((id=ID tipo=Types PARAMETER+=PARAMETER*)? retorno=Result?)
	 */
	protected void sequence_PARAMETER_PARAMETERS_LIST_Parameters_Signature(ISerializationContext context, Parameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PONTOSIGUAL returns PONTOSIGUAL
	 *
	 * Constraint:
	 *     op=':='
	 */
	protected void sequence_PONTOSIGUAL(ISerializationContext context, PONTOSIGUAL semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PONTOSIGUAL__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PONTOSIGUAL__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPONTOSIGUALAccess().getOpColonEqualsSignKeyword_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PostStmt returns PostStmt
	 *
	 * Constraint:
	 *     decl=GoDecl
	 */
	protected void sequence_PostStmt(ISerializationContext context, PostStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.POST_STMT__DECL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.POST_STMT__DECL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPostStmtAccess().getDeclGoDeclParserRuleCall_0(), semanticObject.getDecl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Result returns Result
	 *
	 * Constraint:
	 *     (parametros=Parameters | tipo=Types)
	 */
	protected void sequence_Result(ISerializationContext context, Result semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SignatureDel returns SignatureDel
	 *
	 * Constraint:
	 *     (tipoDecl=TIPO? id=ID type=Types?)
	 */
	protected void sequence_SignatureDel(ISerializationContext context, SignatureDel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TIPO returns TIPO
	 *
	 * Constraint:
	 *     (variavel=Var | constante=Const)
	 */
	protected void sequence_TIPO(ISerializationContext context, TIPO semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Types returns Types
	 *
	 * Constraint:
	 *     (basic=BasicType | array=ArrayType)
	 */
	protected void sequence_Types(ISerializationContext context, Types semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDecl returns VarDecl
	 *
	 * Constraint:
	 *     (signature=SignatureDel ((atribuicao=IGUAL | pront=PONTOSIGUAL) array=ArrayType? expressao=EXPRESSAO)?)
	 */
	protected void sequence_VarDecl(ISerializationContext context, VarDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Var returns Var
	 *
	 * Constraint:
	 *     var='var'
	 */
	protected void sequence_Var(ISerializationContext context, Var semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.VAR__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.VAR__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarAccess().getVarVarKeyword_0(), semanticObject.getVar());
		feeder.finish();
	}
	
	
}
