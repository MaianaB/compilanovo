/*
 * generated by Xtext 2.14.0
 */
package com.ufcg.compiladores.serializer;

import com.google.inject.Inject;
import com.ufcg.compiladores.go.ARIT_EXPR;
import com.ufcg.compiladores.go.ArrayType;
import com.ufcg.compiladores.go.ArrayValue;
import com.ufcg.compiladores.go.Assignment;
import com.ufcg.compiladores.go.BINARY_EXP;
import com.ufcg.compiladores.go.BLOCK;
import com.ufcg.compiladores.go.BOOLEAN_VALUE;
import com.ufcg.compiladores.go.BOOL_OP;
import com.ufcg.compiladores.go.BasicType;
import com.ufcg.compiladores.go.COMPARISON;
import com.ufcg.compiladores.go.Chamada;
import com.ufcg.compiladores.go.Condition;
import com.ufcg.compiladores.go.Const;
import com.ufcg.compiladores.go.EXPRESSAO;
import com.ufcg.compiladores.go.EXPRESSAOLINHA;
import com.ufcg.compiladores.go.ElseCondition;
import com.ufcg.compiladores.go.ForClause;
import com.ufcg.compiladores.go.ForDecl;
import com.ufcg.compiladores.go.FunctionCall;
import com.ufcg.compiladores.go.FunctionType;
import com.ufcg.compiladores.go.GoDecl;
import com.ufcg.compiladores.go.GoPackage;
import com.ufcg.compiladores.go.IDList;
import com.ufcg.compiladores.go.IGUAL;
import com.ufcg.compiladores.go.IfCondition;
import com.ufcg.compiladores.go.IfStmt;
import com.ufcg.compiladores.go.Init;
import com.ufcg.compiladores.go.InitStmt;
import com.ufcg.compiladores.go.LITERAIS_BASICOS;
import com.ufcg.compiladores.go.LiteraisList;
import com.ufcg.compiladores.go.PARAMETER;
import com.ufcg.compiladores.go.PARAMETERS_LIST;
import com.ufcg.compiladores.go.PONTOSIGUAL;
import com.ufcg.compiladores.go.Parameters;
import com.ufcg.compiladores.go.PostStmt;
import com.ufcg.compiladores.go.RangeDecl;
import com.ufcg.compiladores.go.ReturnStmt;
import com.ufcg.compiladores.go.Signature;
import com.ufcg.compiladores.go.SignatureDel;
import com.ufcg.compiladores.go.TIPO;
import com.ufcg.compiladores.go.Types;
import com.ufcg.compiladores.go.Var;
import com.ufcg.compiladores.go.VarCall;
import com.ufcg.compiladores.go.VarDecl;
import com.ufcg.compiladores.services.GoGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class GoSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GoGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GoPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GoPackage.ARIT_EXPR:
				sequence_ARIT_EXPR(context, (ARIT_EXPR) semanticObject); 
				return; 
			case GoPackage.ARRAY_TYPE:
				sequence_ArrayType(context, (ArrayType) semanticObject); 
				return; 
			case GoPackage.ARRAY_VALUE:
				sequence_ArrayValue(context, (ArrayValue) semanticObject); 
				return; 
			case GoPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case GoPackage.BINARY_EXP:
				sequence_BINARY_EXP(context, (BINARY_EXP) semanticObject); 
				return; 
			case GoPackage.BLOCK:
				sequence_BLOCK(context, (BLOCK) semanticObject); 
				return; 
			case GoPackage.BOOLEAN_VALUE:
				sequence_BOOLEAN_VALUE(context, (BOOLEAN_VALUE) semanticObject); 
				return; 
			case GoPackage.BOOL_OP:
				sequence_BOOL_OP(context, (BOOL_OP) semanticObject); 
				return; 
			case GoPackage.BASIC_TYPE:
				sequence_BasicType(context, (BasicType) semanticObject); 
				return; 
			case GoPackage.COMPARISON:
				sequence_COMPARISON(context, (COMPARISON) semanticObject); 
				return; 
			case GoPackage.CHAMADA:
				sequence_Chamada(context, (Chamada) semanticObject); 
				return; 
			case GoPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case GoPackage.CONST:
				sequence_Const(context, (Const) semanticObject); 
				return; 
			case GoPackage.EXPRESSAO:
				sequence_EXPRESSAO(context, (EXPRESSAO) semanticObject); 
				return; 
			case GoPackage.EXPRESSAOLINHA:
				sequence_EXPRESSAOLINHA(context, (EXPRESSAOLINHA) semanticObject); 
				return; 
			case GoPackage.ELSE_CONDITION:
				sequence_ElseCondition(context, (ElseCondition) semanticObject); 
				return; 
			case GoPackage.FOR_CLAUSE:
				sequence_ForClause(context, (ForClause) semanticObject); 
				return; 
			case GoPackage.FOR_DECL:
				sequence_ForDecl(context, (ForDecl) semanticObject); 
				return; 
			case GoPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case GoPackage.FUNCTION_TYPE:
				sequence_FunctionType(context, (FunctionType) semanticObject); 
				return; 
			case GoPackage.GO_DECL:
				sequence_GoDecl(context, (GoDecl) semanticObject); 
				return; 
			case GoPackage.ID_LIST:
				sequence_IDList(context, (IDList) semanticObject); 
				return; 
			case GoPackage.IGUAL:
				sequence_IGUAL(context, (IGUAL) semanticObject); 
				return; 
			case GoPackage.IF_CONDITION:
				sequence_IfCondition(context, (IfCondition) semanticObject); 
				return; 
			case GoPackage.IF_STMT:
				sequence_IfStmt(context, (IfStmt) semanticObject); 
				return; 
			case GoPackage.INIT:
				sequence_Init(context, (Init) semanticObject); 
				return; 
			case GoPackage.INIT_STMT:
				sequence_InitStmt(context, (InitStmt) semanticObject); 
				return; 
			case GoPackage.LITERAIS_BASICOS:
				sequence_LITERAIS_BASICOS(context, (LITERAIS_BASICOS) semanticObject); 
				return; 
			case GoPackage.LITERAIS_LIST:
				sequence_LiteraisList(context, (LiteraisList) semanticObject); 
				return; 
			case GoPackage.PARAMETER:
				sequence_PARAMETER(context, (PARAMETER) semanticObject); 
				return; 
			case GoPackage.PARAMETERS_LIST:
				sequence_PARAMETERS_LIST(context, (PARAMETERS_LIST) semanticObject); 
				return; 
			case GoPackage.PONTOSIGUAL:
				sequence_PONTOSIGUAL(context, (PONTOSIGUAL) semanticObject); 
				return; 
			case GoPackage.PARAMETERS:
				sequence_Parameters(context, (Parameters) semanticObject); 
				return; 
			case GoPackage.POST_STMT:
				sequence_PostStmt(context, (PostStmt) semanticObject); 
				return; 
			case GoPackage.RANGE_DECL:
				sequence_RangeDecl(context, (RangeDecl) semanticObject); 
				return; 
			case GoPackage.RETURN_STMT:
				sequence_ReturnStmt(context, (ReturnStmt) semanticObject); 
				return; 
			case GoPackage.SIGNATURE:
				sequence_Signature(context, (Signature) semanticObject); 
				return; 
			case GoPackage.SIGNATURE_DEL:
				sequence_SignatureDel(context, (SignatureDel) semanticObject); 
				return; 
			case GoPackage.TIPO:
				sequence_TIPO(context, (TIPO) semanticObject); 
				return; 
			case GoPackage.TYPES:
				sequence_Types(context, (Types) semanticObject); 
				return; 
			case GoPackage.VAR:
				sequence_Var(context, (Var) semanticObject); 
				return; 
			case GoPackage.VAR_CALL:
				sequence_VarCall(context, (VarCall) semanticObject); 
				return; 
			case GoPackage.VAR_DECL:
				sequence_VarDecl(context, (VarDecl) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ARIT_EXPR returns ARIT_EXPR
	 *
	 * Constraint:
	 *     (
	 *         ((num1=NUMERO | var1=VarCall) op=ARIT_OP (num2=NUMERO | var2=VarCall)) | 
	 *         ((num=NUMERO | var=VarCall) atr=ARIT_ATR) | 
	 *         (atr=ARIT_ATR (num=NUMERO | var=VarCall))
	 *     )
	 */
	protected void sequence_ARIT_EXPR(ISerializationContext context, ARIT_EXPR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArrayType returns ArrayType
	 *
	 * Constraint:
	 *     (qtd=NUMERO? basic=BasicType)
	 */
	protected void sequence_ArrayType(ISerializationContext context, ArrayType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArrayValue returns ArrayValue
	 *
	 * Constraint:
	 *     lit=LiteraisList
	 */
	protected void sequence_ArrayValue(ISerializationContext context, ArrayValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.ARRAY_VALUE__LIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.ARRAY_VALUE__LIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayValueAccess().getLitLiteraisListParserRuleCall_1_0(), semanticObject.getLit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (id=ID qtd=NUMERO? (igual=IGUAL | dois=PONTOSIGUAL) expressao=EXPRESSAOLINHA)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BINARY_EXP returns BINARY_EXP
	 *
	 * Constraint:
	 *     (
	 *         (basic+=LITERAIS_BASICOS | varCal+=VarCall | func+=FunctionCall) 
	 *         (bool=BOOL_OP | arit=ARIT_OP) 
	 *         (basic+=LITERAIS_BASICOS | varCal+=VarCall | func+=FunctionCall)
	 *     )
	 */
	protected void sequence_BINARY_EXP(ISerializationContext context, BINARY_EXP semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BLOCK returns BLOCK
	 *
	 * Constraint:
	 *     (listaDeComandos+=EXPRESSAO* retorno=ReturnStmt?)
	 */
	protected void sequence_BLOCK(ISerializationContext context, BLOCK semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BOOLEAN_VALUE returns BOOLEAN_VALUE
	 *
	 * Constraint:
	 *     (verdadeiro='true' | falso='false')
	 */
	protected void sequence_BOOLEAN_VALUE(ISerializationContext context, BOOLEAN_VALUE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BOOL_OP returns BOOL_OP
	 *
	 * Constraint:
	 *     {BOOL_OP}
	 */
	protected void sequence_BOOL_OP(ISerializationContext context, BOOL_OP semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicType returns BasicType
	 *
	 * Constraint:
	 *     (string='string' | int='int' | float='float' | boolean='bool')
	 */
	protected void sequence_BasicType(ISerializationContext context, BasicType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     COMPARISON returns COMPARISON
	 *
	 * Constraint:
	 *     (igual='==' | maiorigualque='>=' | menorigualque='<=' | maiorque='>' | menorque='<')
	 */
	protected void sequence_COMPARISON(ISerializationContext context, COMPARISON semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Chamada returns Chamada
	 *
	 * Constraint:
	 *     (cham+=FunctionCall | cham+=VarCall | cham+=LITERAIS_BASICOS)
	 */
	protected void sequence_Chamada(ISerializationContext context, Chamada semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (expr1=EXPRESSAO comparador=COMPARISON expr2=EXPRESSAO)
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONDITION__EXPR1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONDITION__EXPR1));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONDITION__COMPARADOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONDITION__COMPARADOR));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONDITION__EXPR2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONDITION__EXPR2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAccess().getExpr1EXPRESSAOParserRuleCall_0_0(), semanticObject.getExpr1());
		feeder.accept(grammarAccess.getConditionAccess().getComparadorCOMPARISONParserRuleCall_1_0(), semanticObject.getComparador());
		feeder.accept(grammarAccess.getConditionAccess().getExpr2EXPRESSAOParserRuleCall_2_0(), semanticObject.getExpr2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Const returns Const
	 *
	 * Constraint:
	 *     const='const'
	 */
	protected void sequence_Const(ISerializationContext context, Const semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONST__CONST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONST__CONST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstAccess().getConstConstKeyword_0(), semanticObject.getConst());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EXPRESSAOLINHA returns EXPRESSAOLINHA
	 *
	 * Constraint:
	 *     ((exp=EXPRESSAO explinha=EXPRESSAOLINHA) | exp=EXPRESSAO)
	 */
	protected void sequence_EXPRESSAOLINHA(ISerializationContext context, EXPRESSAOLINHA semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EXPRESSAO returns EXPRESSAO
	 *
	 * Constraint:
	 *     (
	 *         declFunction=FunctionType | 
	 *         binary_exp=BINARY_EXP | 
	 *         basic=LITERAIS_BASICOS | 
	 *         assignment=Assignment | 
	 *         for=ForDecl | 
	 *         arrayValue=ArrayValue | 
	 *         variaveis=VarDecl | 
	 *         cham=Chamada | 
	 *         if=IfStmt
	 *     )
	 */
	protected void sequence_EXPRESSAO(ISerializationContext context, EXPRESSAO semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElseCondition returns ElseCondition
	 *
	 * Constraint:
	 *     then+=EXPRESSAO*
	 */
	protected void sequence_ElseCondition(ISerializationContext context, ElseCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForClause returns ForClause
	 *
	 * Constraint:
	 *     (init=InitStmt? condition=Condition? post=PostStmt?)
	 */
	protected void sequence_ForClause(ISerializationContext context, ForClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForDecl returns ForDecl
	 *
	 * Constraint:
	 *     ((clause=ForClause | range=RangeDecl) comandos=GoDecl?)
	 */
	protected void sequence_ForDecl(ISerializationContext context, ForDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCall returns FunctionCall
	 *
	 * Constraint:
	 *     (id=ID params=PARAMETERS_LIST?)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionType returns FunctionType
	 *
	 * Constraint:
	 *     (nome=ID assinatura=Signature bloco=BLOCK?)
	 */
	protected void sequence_FunctionType(ISerializationContext context, FunctionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GoDecl returns GoDecl
	 *
	 * Constraint:
	 *     (var=VarDecl | func=FunctionType | expressao=EXPRESSAOLINHA)
	 */
	protected void sequence_GoDecl(ISerializationContext context, GoDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IDList returns IDList
	 *
	 * Constraint:
	 *     (idList+=ID | (idList+=ID vir+=VIRGULA list+=IDList))
	 */
	protected void sequence_IDList(ISerializationContext context, IDList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IGUAL returns IGUAL
	 *
	 * Constraint:
	 *     igual='='
	 */
	protected void sequence_IGUAL(ISerializationContext context, IGUAL semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.IGUAL__IGUAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.IGUAL__IGUAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIGUALAccess().getIgualEqualsSignKeyword_0(), semanticObject.getIgual());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IfCondition returns IfCondition
	 *     ElseIfCondition returns IfCondition
	 *
	 * Constraint:
	 *     (cond=Condition then+=EXPRESSAO*)
	 */
	protected void sequence_IfCondition(ISerializationContext context, IfCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfStmt returns IfStmt
	 *
	 * Constraint:
	 *     (if=IfCondition elseif+=ElseIfCondition* else=ElseCondition?)
	 */
	protected void sequence_IfStmt(ISerializationContext context, IfStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InitStmt returns InitStmt
	 *
	 * Constraint:
	 *     varDecl=VarDecl
	 */
	protected void sequence_InitStmt(ISerializationContext context, InitStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.INIT_STMT__VAR_DECL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.INIT_STMT__VAR_DECL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitStmtAccess().getVarDeclVarDeclParserRuleCall_0(), semanticObject.getVarDecl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Init returns Init
	 *
	 * Constraint:
	 *     elements+=GoDecl+
	 */
	protected void sequence_Init(ISerializationContext context, Init semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LITERAIS_BASICOS returns LITERAIS_BASICOS
	 *
	 * Constraint:
	 *     (numero=NUMERO | string=STRING_DECL | booleano=BOOLEAN_VALUE)
	 */
	protected void sequence_LITERAIS_BASICOS(ISerializationContext context, LITERAIS_BASICOS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LiteraisList returns LiteraisList
	 *
	 * Constraint:
	 *     (lit+=LITERAIS_BASICOS | (lit+=LITERAIS_BASICOS vir=VIRGULA lit+=LiteraisList))
	 */
	protected void sequence_LiteraisList(ISerializationContext context, LiteraisList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PARAMETERS_LIST returns PARAMETERS_LIST
	 *
	 * Constraint:
	 *     (params+=PARAMETER (vir+=VIRGULA params+=PARAMETER)*)
	 */
	protected void sequence_PARAMETERS_LIST(ISerializationContext context, PARAMETERS_LIST semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PARAMETER returns PARAMETER
	 *
	 * Constraint:
	 *     (basico=LITERAIS_BASICOS | (id=ID tipo=Types?))
	 */
	protected void sequence_PARAMETER(ISerializationContext context, PARAMETER semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PONTOSIGUAL returns PONTOSIGUAL
	 *
	 * Constraint:
	 *     op=':='
	 */
	protected void sequence_PONTOSIGUAL(ISerializationContext context, PONTOSIGUAL semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PONTOSIGUAL__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PONTOSIGUAL__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPONTOSIGUALAccess().getOpColonEqualsSignKeyword_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameters returns Parameters
	 *
	 * Constraint:
	 *     params=PARAMETERS_LIST?
	 */
	protected void sequence_Parameters(ISerializationContext context, Parameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PostStmt returns PostStmt
	 *
	 * Constraint:
	 *     art=ARIT_EXPR
	 */
	protected void sequence_PostStmt(ISerializationContext context, PostStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.POST_STMT__ART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.POST_STMT__ART));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPostStmtAccess().getArtARIT_EXPRParserRuleCall_0(), semanticObject.getArt());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RangeDecl returns RangeDecl
	 *
	 * Constraint:
	 *     (idList+=IDList (igual=IGUAL | op=PONTOSIGUAL) (variavel=VarCall | func=FunctionCall))
	 */
	protected void sequence_RangeDecl(ISerializationContext context, RangeDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnStmt returns ReturnStmt
	 *
	 * Constraint:
	 *     (basic=LITERAIS_BASICOS | func=FunctionCall | idVar=VarCall)?
	 */
	protected void sequence_ReturnStmt(ISerializationContext context, ReturnStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SignatureDel returns SignatureDel
	 *
	 * Constraint:
	 *     (tipoDecl=TIPO id=ID type=Types?)
	 */
	protected void sequence_SignatureDel(ISerializationContext context, SignatureDel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Signature returns Signature
	 *
	 * Constraint:
	 *     (params=Parameters retorno=Types?)
	 */
	protected void sequence_Signature(ISerializationContext context, Signature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TIPO returns TIPO
	 *
	 * Constraint:
	 *     (variavel=Var | constante=Const)
	 */
	protected void sequence_TIPO(ISerializationContext context, TIPO semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Types returns Types
	 *
	 * Constraint:
	 *     (basic=BasicType | array=ArrayType)
	 */
	protected void sequence_Types(ISerializationContext context, Types semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarCall returns VarCall
	 *
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_VarCall(ISerializationContext context, VarCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.VAR_CALL__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.VAR_CALL__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarCallAccess().getIdIDTerminalRuleCall_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarDecl returns VarDecl
	 *
	 * Constraint:
	 *     (signature=SignatureDel (atribuicao=IGUAL | pront=PONTOSIGUAL)? (array=ArrayType? expressao=EXPRESSAOLINHA)?)
	 */
	protected void sequence_VarDecl(ISerializationContext context, VarDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Var returns Var
	 *
	 * Constraint:
	 *     var='var'
	 */
	protected void sequence_Var(ISerializationContext context, Var semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.VAR__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.VAR__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarAccess().getVarVarKeyword_0(), semanticObject.getVar());
		feeder.finish();
	}
	
	
}
