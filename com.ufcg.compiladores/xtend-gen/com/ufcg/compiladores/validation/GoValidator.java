/**
 * generated by Xtext 2.14.0
 */
package com.ufcg.compiladores.validation;

import com.ufcg.compiladores.go.ArrayType;
import com.ufcg.compiladores.go.Assignment;
import com.ufcg.compiladores.go.BINARY_EXP;
import com.ufcg.compiladores.go.BOOLEAN_VALUE;
import com.ufcg.compiladores.go.BasicType;
import com.ufcg.compiladores.go.Const;
import com.ufcg.compiladores.go.EXPRESSAO;
import com.ufcg.compiladores.go.EXPRESSAOLINHA;
import com.ufcg.compiladores.go.ForClause;
import com.ufcg.compiladores.go.ForDecl;
import com.ufcg.compiladores.go.FunctionCall;
import com.ufcg.compiladores.go.FunctionType;
import com.ufcg.compiladores.go.GoPackage;
import com.ufcg.compiladores.go.Init;
import com.ufcg.compiladores.go.InitStmt;
import com.ufcg.compiladores.go.LITERAIS_BASICOS;
import com.ufcg.compiladores.go.PARAMETER;
import com.ufcg.compiladores.go.PARAMETERS_LIST;
import com.ufcg.compiladores.go.RangeDecl;
import com.ufcg.compiladores.go.ReturnStmt;
import com.ufcg.compiladores.go.Types;
import com.ufcg.compiladores.go.VarCall;
import com.ufcg.compiladores.go.VarDecl;
import com.ufcg.compiladores.validation.AbstractGoValidator;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class GoValidator extends AbstractGoValidator {
  private HashMap<String, VarDecl> variaveis = new HashMap<String, VarDecl>();
  
  private HashMap<String, FunctionType> functions = CollectionLiterals.<String, FunctionType>newHashMap();
  
  public String getTipo(final BasicType lit) {
    String _boolean = lit.getBoolean();
    boolean _tripleNotEquals = (_boolean != null);
    if (_tripleNotEquals) {
      return "bool";
    } else {
      String _int = lit.getInt();
      boolean _tripleNotEquals_1 = (_int != null);
      if (_tripleNotEquals_1) {
        return "int";
      } else {
        String _float = lit.getFloat();
        boolean _tripleNotEquals_2 = (_float != null);
        if (_tripleNotEquals_2) {
          return "float";
        } else {
          return "string";
        }
      }
    }
  }
  
  @Check
  public void restart(final Init init) {
    this.variaveis.clear();
    this.functions.clear();
  }
  
  @Check
  public void checaFuncDecl(final FunctionType func) {
    boolean _containsKey = this.functions.containsKey(func.getNome());
    boolean _not = (!_containsKey);
    if (_not) {
      this.functions.put(func.getNome(), func);
    } else {
      this.error("Função com esse nome já declarada", null);
    }
    EList<EXPRESSAO> _listaDeComandos = func.getBloco().getListaDeComandos();
    for (final EXPRESSAO comando : _listaDeComandos) {
      VarDecl _variaveis = comando.getVariaveis();
      boolean _tripleNotEquals = (_variaveis != null);
      if (_tripleNotEquals) {
      } else {
        FunctionType _declFunction = comando.getDeclFunction();
        boolean _tripleNotEquals_1 = (_declFunction != null);
        if (_tripleNotEquals_1) {
        }
      }
    }
    Types _retorno = func.getAssinatura().getRetorno();
    boolean _tripleNotEquals_2 = (_retorno != null);
    if (_tripleNotEquals_2) {
      ReturnStmt _retorno_1 = func.getBloco().getRetorno();
      boolean _tripleEquals = (_retorno_1 == null);
      if (_tripleEquals) {
        this.error("Função exige retorno", null);
      } else {
        String tipoEsperado = this.getTipo(func.getAssinatura().getRetorno().getBasic());
        String tipoInserido = null;
        LITERAIS_BASICOS _basic = func.getBloco().getRetorno().getBasic();
        boolean _tripleNotEquals_3 = (_basic != null);
        if (_tripleNotEquals_3) {
          BOOLEAN_VALUE _booleano = func.getBloco().getRetorno().getBasic().getBooleano();
          boolean _tripleNotEquals_4 = (_booleano != null);
          if (_tripleNotEquals_4) {
            tipoInserido = "bool";
          } else {
            String _numero = func.getBloco().getRetorno().getBasic().getNumero();
            boolean _tripleNotEquals_5 = (_numero != null);
            if (_tripleNotEquals_5) {
              tipoInserido = "int";
            } else {
              String _string = func.getBloco().getRetorno().getBasic().getString();
              boolean _tripleNotEquals_6 = (_string != null);
              if (_tripleNotEquals_6) {
                tipoInserido = "string";
              }
            }
          }
        } else {
          FunctionCall _func = func.getBloco().getRetorno().getFunc();
          boolean _tripleNotEquals_7 = (_func != null);
          if (_tripleNotEquals_7) {
            FunctionType funcRetorno = this.functions.get(func.getBloco().getRetorno().getFunc().getId());
            if ((funcRetorno == null)) {
              this.error("Função não declara no contexto.", null);
            } else {
              tipoInserido = this.getTipo(funcRetorno.getAssinatura().getRetorno().getBasic());
            }
          } else {
            VarDecl variavel = this.variaveis.get(func.getBloco().getRetorno().getIdVar().getId());
            if ((variavel == null)) {
              this.error("Variável não declarada.", null);
            } else {
              tipoInserido = this.getTipo(variavel.getSignature().getType().getBasic());
            }
          }
        }
        boolean _equals = tipoEsperado.equals(tipoInserido);
        boolean _not_1 = (!_equals);
        if (_not_1) {
          this.error(((("Tipo de retorno inválido. Esperado " + tipoEsperado) + 
            " mas teve ") + tipoInserido), null);
        }
      }
    }
  }
  
  @Check
  public void checaVariavelDeclaradaSemInicializar(final VarDecl varDecl) {
    boolean _containsKey = this.variaveis.containsKey(varDecl.getSignature().getId());
    boolean _not = (!_containsKey);
    if (_not) {
      this.variaveis.put(varDecl.getSignature().getId(), varDecl);
    } else {
      this.error("Variável já declarada", null);
    }
    EXPRESSAOLINHA _expressao = varDecl.getExpressao();
    boolean _tripleEquals = (_expressao == null);
    if (_tripleEquals) {
      this.warning("Variável declarada sem inicialização", GoPackage.Literals.VAR_DECL__EXPRESSAO);
    }
  }
  
  @Check
  public void checaChamadaAVarDeclarada(final VarCall cal) {
    boolean _containsKey = this.variaveis.containsKey(cal.getId());
    boolean _not = (!_containsKey);
    if (_not) {
      this.error("Variável não declarada", null);
    }
  }
  
  public List<String> getParametersType(final PARAMETERS_LIST params) {
    List<String> tipos = new ArrayList<String>();
    if (((params != null) && (params.getParams() != null))) {
      EList<PARAMETER> _params = params.getParams();
      for (final PARAMETER parametro : _params) {
        tipos.add(this.getTipo(parametro.getTipo().getBasic()));
      }
    }
    return tipos;
  }
  
  public List<String> getParametersCall(final PARAMETERS_LIST params) {
    List<String> tipos = new ArrayList<String>();
    if (((params != null) && (params.getParams() != null))) {
      EList<PARAMETER> _params = params.getParams();
      for (final PARAMETER parametro : _params) {
        LITERAIS_BASICOS _basico = parametro.getBasico();
        boolean _tripleNotEquals = (_basico != null);
        if (_tripleNotEquals) {
          BOOLEAN_VALUE _booleano = parametro.getBasico().getBooleano();
          boolean _tripleNotEquals_1 = (_booleano != null);
          if (_tripleNotEquals_1) {
            tipos.add("bool");
          } else {
            String _numero = parametro.getBasico().getNumero();
            boolean _tripleNotEquals_2 = (_numero != null);
            if (_tripleNotEquals_2) {
              tipos.add("int");
            } else {
              tipos.add("string");
            }
          }
        } else {
          tipos.add(this.getTipo(this.variaveis.get(parametro.getId()).getSignature().getType().getBasic()));
        }
      }
    }
    return tipos;
  }
  
  @Check
  public void checaChamadaAFuncao(final FunctionCall func) {
    boolean _containsKey = this.functions.containsKey(func.getId());
    boolean _not = (!_containsKey);
    if (_not) {
      this.error("Função não declarada", null);
    } else {
      PARAMETERS_LIST callParams = func.getParams();
      PARAMETERS_LIST funcParams = this.functions.get(func.getId()).getAssinatura().getParams().getParams();
      List<String> tiposFuncao = this.getParametersType(funcParams);
      List<String> tiposChamada = this.getParametersCall(callParams);
      int _size = tiposChamada.size();
      int _size_1 = tiposFuncao.size();
      boolean _tripleNotEquals = (_size != _size_1);
      if (_tripleNotEquals) {
        int _size_2 = tiposFuncao.size();
        String _plus = ("Número de parâmetros errado. Esperado " + Integer.valueOf(_size_2));
        String _plus_1 = (_plus + " mas obteve ");
        int _size_3 = tiposChamada.size();
        String _plus_2 = (_plus_1 + Integer.valueOf(_size_3));
        this.error(_plus_2, null);
      } else {
        for (int i = 0; (i < tiposFuncao.size()); i++) {
          boolean _equals = tiposFuncao.get(i).equals(tiposChamada.get(i));
          boolean _not_1 = (!_equals);
          if (_not_1) {
            String _get = tiposFuncao.get(i);
            String _plus_3 = ("Tipo inesperado. Tipo esperado: " + _get);
            String _plus_4 = (_plus_3 + 
              " , Tipo obtido: ");
            String _get_1 = tiposChamada.get(i);
            String _plus_5 = (_plus_4 + _get_1);
            this.error(_plus_5, null);
          }
        }
      }
    }
  }
  
  @Check
  public void checaAtribuicaoSemValor(final Assignment a) {
    EXPRESSAOLINHA _expressao = a.getExpressao();
    boolean _tripleEquals = (_expressao == null);
    if (_tripleEquals) {
      this.error("É necessário inicializar um valor", null);
    }
  }
  
  @Check
  public void checaAtribuicaoAConstante(final Assignment a) {
    if ((this.isVarDeclarada(a.getId()) && (this.variaveis.get(a.getId()).getSignature().getTipoDecl() instanceof Const))) {
      this.error("Não é possível reatribuir o valor de uma constante", null);
    }
  }
  
  @Check
  public void checaFor(final ForDecl forDecl) {
    RangeDecl _range = forDecl.getRange();
    boolean _tripleNotEquals = (_range != null);
    if (_tripleNotEquals) {
      this.checaVarDoRange(forDecl.getRange());
    } else {
      ForClause _clause = forDecl.getClause();
      boolean _tripleNotEquals_1 = (_clause != null);
      if (_tripleNotEquals_1) {
        this.checaForNormal(forDecl.getClause());
      }
    }
  }
  
  @Check
  public void checaBinaryExpr(final BINARY_EXP bin) {
    EList<LITERAIS_BASICOS> _basic = bin.getBasic();
    boolean _tripleNotEquals = (_basic != null);
    if (_tripleNotEquals) {
      EList<LITERAIS_BASICOS> _basic_1 = bin.getBasic();
      for (final LITERAIS_BASICOS lit : _basic_1) {
        BOOLEAN_VALUE _booleano = lit.getBooleano();
        boolean _tripleEquals = (_booleano == null);
        if (_tripleEquals) {
          this.error("Tipo do literal deve ser bool", null);
        }
      }
    } else {
      EList<VarCall> _varCal = bin.getVarCal();
      boolean _tripleNotEquals_1 = (_varCal != null);
      if (_tripleNotEquals_1) {
        EList<VarCall> _varCal_1 = bin.getVarCal();
        for (final VarCall call : _varCal_1) {
          {
            VarDecl variavel = this.variaveis.get(call.getId());
            String _boolean = variavel.getSignature().getType().getBasic().getBoolean();
            boolean _tripleEquals_1 = (_boolean == null);
            if (_tripleEquals_1) {
              this.error("Tipo da variável deve ser bool", null);
            }
          }
        }
      } else {
        EList<FunctionCall> _func = bin.getFunc();
        boolean _tripleNotEquals_2 = (_func != null);
        if (_tripleNotEquals_2) {
          EList<FunctionCall> _func_1 = bin.getFunc();
          for (final FunctionCall func : _func_1) {
            {
              FunctionType function = this.functions.get(func.getId());
              String _boolean = function.getAssinatura().getRetorno().getBasic().getBoolean();
              boolean _tripleEquals_1 = (_boolean == null);
              if (_tripleEquals_1) {
                this.error("Tipo de retorno da função deve ser bool", null);
              }
            }
          }
        }
      }
    }
  }
  
  public void checaForNormal(final ForClause clause) {
    InitStmt _init = clause.getInit();
    boolean _tripleNotEquals = (_init != null);
    if (_tripleNotEquals) {
      String tipo = this.getTipo(clause.getInit().getVarDecl().getSignature().getType().getBasic());
      String _int = clause.getInit().getVarDecl().getSignature().getType().getBasic().getInt();
      boolean _tripleEquals = (_int == null);
      if (_tripleEquals) {
        this.error(("Tipo da variável de controle do laço deve ser numérica " + tipo), null);
      }
    }
  }
  
  public void checaVarDoRange(final RangeDecl range) {
    VarCall _variavel = range.getVariavel();
    boolean _tripleNotEquals = (_variavel != null);
    if (_tripleNotEquals) {
      VarDecl variavel = this.variaveis.get(range.getVariavel().getId());
      ArrayType _array = variavel.getArray();
      boolean _tripleEquals = (_array == null);
      if (_tripleEquals) {
        this.error("Tipo esperado é array", null);
      }
    } else {
      FunctionCall _func = range.getFunc();
      boolean _tripleNotEquals_1 = (_func != null);
      if (_tripleNotEquals_1) {
        FunctionType function = this.functions.get(range.getFunc().getId());
        ArrayType _array_1 = function.getAssinatura().getRetorno().getArray();
        boolean _tripleEquals_1 = (_array_1 == null);
        if (_tripleEquals_1) {
          this.error("Retorno da função deve ser do tipo Array", null);
        }
      }
    }
  }
  
  public boolean isVarDeclarada(final String id) {
    return this.variaveis.containsKey(id);
  }
}
